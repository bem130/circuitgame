<!DOCTYPE html>
<html>
    <head>
        <script src="three.min.js"></script>
        <script src="OrbitControls.js"></script>
    </head>
    <body>
        <select onchange="onChange(this.value)">
            <option value="0-0.png">Circle</option>
            <option value="0-1.png">Gori</option>
        </select>
        <canvas id="imgout"></canvas>
    </body>
</html>
<script>

{

function getimg(img) {
    let canvas = document.createElement("canvas");
    canvas.height = img.naturalHeight;
    canvas.width = img.naturalWidth;
    let ctx = canvas.getContext("2d");
    ctx.drawImage(img,0,0);
    return ctx.getImageData(0,0,img.naturalWidth,img.naturalHeight);
}
    
const width = 64;
const height = 64;

const size = width * height;
const data = new Uint8Array( 4 * size );

for ( let i = 0; i < size; i ++ ) {

	const stride = i * 4;

	data[ stride ] = (i*5)%200+50;
	data[ stride + 1 ] = (i*5)%200+50;
	data[ stride + 2 ] = (i*5)%200+50;
	data[ stride + 3 ] = 255;

}

// used the buffer to create a DataTexture

var texture = new THREE.DataTexture( data, width, height );
texture.needsUpdate = true;
}

    
var ssize = [640,460]

var canvas = document.getElementById("imgout")
// シーン
var scene = new THREE.Scene();



// レンダラー
var renderer = new THREE.WebGLRenderer({canvas:canvas});
renderer.setSize( ssize[0],ssize[1] );
canvas.style.removeProperty("height");
canvas.style.removeProperty("width");

// カメラ
var camera = new THREE.PerspectiveCamera( 50, ssize[0] / ssize[1], 1, 1000 );
    camera.position.set(0,00,100);
var controls = new THREE.OrbitControls(camera, canvas);

// ライト
var ambientlight = new THREE.AmbientLight(0xFFFFFF, 0.1);
scene.add(ambientlight);
var directionalLight = new THREE.DirectionalLight('#aaaaff', 1);
directionalLight.position.set(10, 20, 15);
scene.add(directionalLight);

{
    
    function datato3d() {
        x = blks[0].length;
        y = blks.length;
        z = blks[0][0].length;
        scene["game"] = [[0],[]];
        fmaze = scene["game"][1];
        for (let ly=0;ly<y;ly++) {
            for (let lx=0;lx<x;lx++) {
                for(let lz=0;lz<z;lz++) {
                    if (blks[ly][lx][lz]!=0) {
                        c = blkcs[blks[ly][lx][lz]];
                        // console.log(blks[ly][lx][lz])
                        // 上面
                        if (!(lx>0&&blks[ly][lx][lz+1]!=0)||blks[ly][lx][lz+1]==null) {
                            fmaze.push([[lx,ly,lz+1],[lx+1,ly,lz+1],[lx+1,ly+1,lz+1],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[0,0,1]])
                            fmaze.push([[lx,ly+1,lz+1],[lx,ly,lz+1],[lx+1,ly+1,lz+1],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[0,0,1]])
                        }
                        // 底面
                        if (!(lx>0&&blks[ly][lx][lz-1]!=0)||blks[ly][lx][lz-1]==null) {
                            fmaze.push([[lx,ly,lz+0],[lx+1,ly+1,lz+0],[lx+1,ly,lz+0],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[0,0,-1]])
                            fmaze.push([[lx,ly+1,lz+0],[lx+1,ly+1,lz+0],[lx,ly,lz+0],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[0,0,-1]])
                        }
                        // 横面
                        if (!(lx>0&&blks[ly][lx-1][lz]!=0)) {
                            fmaze.push([[lx,ly,lz+0],[lx,ly,lz+1],[lx,ly+1,lz+0],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[-1,0,0]]);
                            fmaze.push([[lx,ly,lz+1],[lx,ly+1,lz+1],[lx,ly+1,lz+0],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[-1,0,0]]);
                        }
                        
                        if (!(ly<y-1&&blks[ly+1][lx][lz]!=0)) {
                            fmaze.push([[lx,ly+1,lz+0],[lx,ly+1,lz+1],[lx+1,ly+1,lz+1],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[0,1,0]]);
                            fmaze.push([[lx+1,ly+1,lz+0],[lx,ly+1,lz+0],[lx+1,ly+1,lz+1],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[0,1,0]]);
                        }
                        
                        if (!(lx<x-1&&blks[ly][lx+1][lz]!=0)) {
                            fmaze.push([[lx+1,ly+1,lz+0],[lx+1,ly+1,lz+1],[lx+1,ly,lz+1],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[1,0,0]]);
                            fmaze.push([[lx+1,ly,lz+0],[lx+1,ly+1,lz+0],[lx+1,ly,lz+1],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[1,0,0]]);
                        }
                        
                        if (!(ly>0&&blks[ly-1][lx][lz]!=0)) {
                            fmaze.push([[lx+1,ly,lz+0],[lx+1,ly,lz+1],[lx,ly,lz+1],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[0,-1,0]]);
                            fmaze.push([[lx,ly,lz+0],[lx+1,ly,lz+0],[lx,ly,lz+1],[0],[c[0]],[c[1]],[c[2]],[0],[lx,ly,lz],[0,-1,0]]);
                        }
    
                    }
                }
            }
        }
        // console.log(fmaze)
    }

}
// キューブ
geometry = new THREE.PlaneGeometry( 1,1,1 );
var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.SingleSide} );
var cube = new THREE.Mesh( geometry, material );
cube.name = "cube"
cube.position.set(0, 0, 0);
cube.rotation.x = 1;
scene.add( cube );

// レンダリング
function render() {
    requestAnimationFrame(render);
    renderer.render(scene, camera);
}
render();


function onChange(val) {
        console.log(val)
        const object = scene.getObjectByName("cube");
        const loader = new THREE.CubeTextureLoader();
const material = new THREE.MeshBasicMaterial( { color: 0xffffff, map: texture } );
        object.material = material
        object.material.needsUpdate = true;
    }
</script>
<script>
// resize window
function resizeImg() {
    canvas = document.getElementById("imgout");
    dw = canvas.width;
    dh = canvas.height;
    let bottom_area = 0;
    let left_area = 0;
    let rw = 0;let rh = 0;
    let ww = window.innerWidth-left_area;
    let wh = window.innerHeight-bottom_area;
    let csc = 1;
    hcsc = ww/dw;
    wcsc = wh/dh;
    // console.log(hcsc,wcsc)
    if (hcsc>wcsc) {
        csc = wcsc;
        rw = (ww - dw*csc)/2;
    }
    else {
        csc = hcsc;
        rh = (wh - dh*csc)/2;
    }
    canvas.style.marginTop = (rh).toString()+"px";
    canvas.style.marginBottom = (rh+bottom_area).toString()+"px";
    canvas.style.marginLeft = (rw+left_area).toString()+"px";
    canvas.style.marginRight = (rw).toString()+"px";
    canvas.style.transform = "scale("+csc.toString()+","+csc.toString()+")";
};
resizeImg();
window.onresize = resizeImg;
</script>
<style>
    body {
        margin: 0px;
    }
    #imgout {
        transform-origin: right top;
        position: fixed;
        top: 0;
        right: 0;
        cursor: cell;
    }
</style>