<!DOCTYPE html>
<html>
    <haed>
        <title>circuit</title>
        <meta charset="utf-8">
    </haed>
    <body>
        <canvas id="imgOut"></canvas>
    </body>
</html>
<script>
    size = [15,20]

    blockdef = { // definition of blocks - id: [[buffer],[not],sp]
        0: [[],[],0], // 空ブロック
        1: [[],[],1], // 信号源ブロック
        2: [[[-1,0]],[],0], // 右向き配線ブロック
        3: [[[0,-1]],[],0], // 下向き配線ブロック
        4: [[[1,0]],[],0], // 左向き配線ブロック
        5: [[],[[0,1]],0], // 上向き配線ブロック
        6: [[[-2,0]],[],0], // 右向きジャンプブロック
        7: [[[0,-2]],[],0], // 下向きジャンプブロック
        8: [[[2,0]],[],0], // 左向きジャンプブロック
        9: [[],[[0,2]],0], // 上向きジャンプブロック
        10: [[],[[-1,0]],0], // 右向きNOTブロック
        11: [[],[[0,-1]],0], // 下向きNOTブロック
        12: [[],[[1,0]],0], // 左向きNOTブロック
        13: [[],[[0,1]],0], // 上向きNOTブロック
        14: [[[1,0],[0,-1]],[],0], // 右上ORブロック
        15: [[[1,0],[0,1]],[],0], // 右下ORブロック
        16: [[[-1,0],[0,-1]],[],0], // 左上ORブロック
        17: [[[-1,0],[0,1]],[],0], // 左下ORブロック
        18: [[[-1,0],[1,0]],[],0], // 左右ORブロック
        19: [[[0,-1],[0,1]],[],0], // 上下ORブロック
        20: [[],[],2], // スイッチブロック
    }

    blarr = new Uint8ClampedArray(size[0]*size[1]).fill(0);
    function makeblarr() {
        let blcks = [
            [01,00,01,00,01,00,00,00,00,00],
            [03,00,03,00,03,02,02,10,00,00],
            [03,00,03,02,03,06,10,16,00,00],
            [03,00,03,02,16,00,00,11,02,00],
            [03,00,00,00,11,02,02,16,03,00],
            [03,00,04,04,04,04,04,11,03,00],
            [03,00,03,00,00,00,00,00,03,00],
            [03,00,03,02,02,10,00,00,03,00],
            [03,02,03,06,10,16,00,00,03,00],
            [03,02,16,00,00,11,02,02,16,00],
            [00,00,11,02,02,16,00,00,03,00],
            [00,00,00,00,00,11,00,00,03,00],
            [00,00,00,00,00,03,00,00,03,00],
            [00,00,00,00,00,03,00,00,03,00],
            [00,00,00,00,00,03,00,00,03,00],
        ];
        for (let iy=0;iy<blcks.length;iy++) {
            for (let ix=0;ix<blcks[0].length;ix++) {
                let idx = (iy*size[0]+ix);
                blarr[idx] = blcks[iy][ix];
            }
        }
    }


    delay = 100
    autoplay = true
    function first() {
        barr = new Uint8ClampedArray(size[0]*size[1]).fill(0);
        swarr = new Uint8ClampedArray(size[0]*size[1]).fill(0);
        makeblarr();
        mkimg(barr);
        if (autoplay) {
            setTimeout(next,delay);
        }
        // resizeImg();
    }

    function swchange(x,y) {
        let idx = y*size[0]+x
        if (swarr[idx]==1) {
            swarr[idx] = 0;
        }
        else {
            swarr[idx] = 1;
        }
    }

    function next() {
        let narr = new Uint8ClampedArray(size[0]*size[1]).fill(0);
        for (let iy = 0; iy < size[1]; iy++) {

            for (let ix = 0; ix < size[0]; ix++) {
                let ii = iy*size[0]+ix;
                let blkprc = blockdef[blarr[ii]];
                //console.log(blkprc,blarr[ii],ii)
                if (blkprc[2]==1) {
                    narr[ii] = 1;
                    continue;
                }
                else if (blkprc[2]==2) {
                    if (swarr[ii]==1) {
                        narr[ii] = 1;
                        continue;
                    }
                }
                for (i=0;i<blkprc[0].length;i++) {
                    let bi = (iy+blkprc[0][i][1])*size[0]+ix+blkprc[0][i][0]
                    if (barr[bi]==1) {
                        narr[ii] = 1;
                    }
                }
                for (i=0;i<blkprc[1].length;i++) {
                    let bi = (iy+blkprc[1][i][1])*size[0]+ix+blkprc[1][i][0]
                    if (barr[bi]==0) {
                        narr[ii] = 1;
                    }
                }
            }
        }
        barr = narr;
        mkimg(barr);
        if (autoplay) {
            setTimeout(next,delay);
        }
    }
first()




    function mkimg(barr) {
        let iarr = new Uint8ClampedArray(size[0]*size[1]*4).fill(255);
        for (let i=0;i<size[0]*size[1];i++) {
            iarr[i*4+0] = barr[i]*255
            iarr[i*4+1] = barr[i]*255
            iarr[i*4+2] = barr[i]*255
        }
        let co = document.getElementById("imgOut");
        co.height=size[1];co.width=size[0];co.getContext('2d').putImageData(new ImageData(iarr,size[0],size[1]),0,0);
    }

</script>
<script>
// resize window
function resizeImg() {
    canvas = document.getElementById("imgOut")
    dw = canvas.width;
    dh = canvas.height;
    let bottom_area = 0;
    let rw = 0;let rh = 0;
    let ww = window.innerWidth;
    let wh = window.innerHeight-bottom_area;
    let csc = 1
    hcsc = ww/dw
    wcsc = wh/dh
    // console.log(hcsc,wcsc)
    if (hcsc>wcsc) {
        csc = wcsc
        rw = (ww - dw*csc)/2
    }
    else {
        csc = hcsc
        rh = (wh - dh*csc)/2
    }
    canvas.style.marginTop = (rh).toString()+"px";
    canvas.style.marginBottom = (rh).toString()+"px";
    canvas.style.marginLeft = (rw).toString()+"px";
    canvas.style.marginRight = (rw).toString()+"px";
    canvas.style.transform = "scale("+csc.toString()+","+csc.toString()+")";
};
resizeImg();
window.onresize = resizeImg;
</script>
<style>
    body {
        background-color:bisque;
    }
    #imgOut {
        transform-origin: left top;
        position: absolute;
        top: 0;
        left: 0;
        image-rendering: pixelated;
    }
</style>